<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Virtual Currency Price & Volume Chart</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body {
    background: #0f111a;
    color: #00ff88;
    font-family: Arial, sans-serif;
    text-align: center;
    margin: 0;
    padding: 0;
  }
  h1 { margin: 15px 0; }
  canvas { display: block; margin: 0 auto; }
  .hoverBox {
    position: absolute;
    background: rgba(0,0,0,0.8);
    border: 1px solid #444;
    border-radius: 8px;
    padding: 10px;
    color: white;
    font-size: 14px;
    pointer-events: none;
    display: none;
    white-space: nowrap;
  }
</style>
</head>
<body>

<h1>Virtual Currency Price Trend</h1>
<input id="coinInput" placeholder="Enter coin symbols (e.g. BTC, ACA)" style="width:260px;">
<button id="updateBtn">Update Chart</button>
<button id="addBtn">Add Coin</button>
<button id="smoothBtn">Point Smooth</button>
<p id="updateTime">Ready.</p>

<div style="position:relative; width:95%; margin:auto;">
  <canvas id="priceChart" height="300"></canvas>
  <canvas id="volumeChart" height="100"></canvas>
  <div id="hoverBox" class="hoverBox"></div>
</div>

<script>
const ctx1 = document.getElementById('priceChart');
const ctx2 = document.getElementById('volumeChart');
const hoverBox = document.getElementById('hoverBox');
let smoothMode = false;
let datasets = [];
let volumeDatasets = [];
let chart1, chart2;
let currentCoins = [];

function fmtVal(v, isQVol=false) {
  if (isQVol) return parseFloat(v).toFixed(2);
  const n = parseFloat(v);
  if (Math.abs(n) < 0.001 && n !== 0) return n.toExponential(2);
  return n.toFixed(5);
}

async function fetchKline(symbol, bar='1D') {
  const res = await fetch(`https://www.okx.com/api/v5/market/candles?instId=${symbol}-USDT&bar=${bar}`);
  const json = await res.json();
  return json.data.map(d => ({
    time: new Date(+d[0]),
    open: d[1], high: d[2], low: d[3], close: d[4], qVol: d[6]
  })).reverse();
}

function createCharts() {
  chart1 = new Chart(ctx1, {
    type: 'line',
    data: { labels: [], datasets: [] },
    options: {
      interaction: { mode: 'nearest', intersect: false },
      plugins: { legend: { labels: { color: '#fff' }}, tooltip: { enabled: false } },
      scales: {
        x: { ticks: { color: '#aaa' } },
        y: { ticks: { color: '#aaa' }, grid: { color: '#222' } }
      },
      onHover: showHover
    }
  });
  chart2 = new Chart(ctx2, {
    type: 'bar',
    data: { labels: [], datasets: [] },
    options: {
      scales: {
        x: { ticks: { display: false } },
        y: { ticks: { color: '#888' }, grid: { color: '#222' } }
      },
      plugins: { legend: { display: false }, tooltip: { enabled: false } }
    }
  });
}
createCharts();

async function updateChart() {
  const coins = document.getElementById('coinInput').value.trim().toUpperCase();
  if (!coins) return;
  const arr = coins.split(',').map(c=>c.trim()).filter(c=>c);
  if (!arr.length) return;
  currentCoins = [arr[0]];
  datasets = []; volumeDatasets = [];
  chart1.data.datasets = []; chart2.data.datasets = [];
  for (let coin of arr.slice(0,1)) {
    const data = await fetchKline(coin);
    const labels = data.map(d => d.time.toLocaleString());
    const closes = data.map(d => +d.close);
    chart1.data.labels = labels;
    chart1.data.datasets.push({
      label: `${coin}/USDT`,
      data: closes,
      borderColor: '#00ff88',
      tension: smoothMode ? 0.4 : 0,
      pointRadius: smoothMode ? 0 : 3
    });
    chart2.data.labels = labels;
    chart2.data.datasets.push({
      label: `${coin} Vol`,
      data: data.map(d => +d.qVol),
      backgroundColor: 'rgba(0,255,136,0.4)'
    });
  }
  chart1.update(); chart2.update();
  document.getElementById('updateTime').innerText = 'Updated: ' + new Date().toLocaleTimeString();
}

async function addCoin() {
  const coins = document.getElementById('coinInput').value.trim().toUpperCase();
  const arr = coins.split(',').map(c=>c.trim()).filter(c=>c && !currentCoins.includes(c));
  const colors = ['#00ff88','#ff4444','#44aaff','#ffaa00','#bb44ff','#00dddd'];
  for (let coin of arr) {
    const data = await fetchKline(coin);
    if (!chart1.data.labels.length)
      chart1.data.labels = data.map(d=>d.time.toLocaleString());
    chart1.data.datasets.push({
      label: `${coin}/USDT`,
      data: data.map(d=>+d.close),
      borderColor: colors[(chart1.data.datasets.length)%colors.length],
      tension: smoothMode ? 0.4 : 0,
      pointRadius: smoothMode ? 0 : 3
    });
    chart2.data.datasets.push({
      label: `${coin} Vol`,
      data: data.map(d=>+d.qVol),
      backgroundColor: colors[(chart2.data.datasets.length)%colors.length]+'66'
    });
    currentCoins.push(coin);
  }
  chart1.update(); chart2.update();
  document.getElementById('updateTime').innerText = 'Added: ' + new Date().toLocaleTimeString();
  document.getElementById('addBtn').innerText = 'Delete Coin';
  document.getElementById('addBtn').onclick = deleteCoin;
}

function deleteCoin() {
  chart1.data.datasets = [];
  chart2.data.datasets = [];
  currentCoins = [];
  chart1.update(); chart2.update();
  document.getElementById('addBtn').innerText = 'Add Coin';
  document.getElementById('addBtn').onclick = addCoin;
}

function showHover(evt, chartEl) {
  if (smoothMode) { hoverBox.style.display = 'none'; return; }
  const points = chart1.getElementsAtEventForMode(evt, 'nearest', { intersect: false }, true);
  if (!points.length) { hoverBox.style.display = 'none'; return; }
  const i = points[0].index;
  const html = [];
  const time = chart1.data.labels[i];
  html.push(`<b>Time:</b> ${time}<br>`);
  html.push(`<b>Coins:</b> ${chart1.data.datasets.map(ds => `<span style="color:${ds.borderColor}">${ds.label.split('/')[0]}</span>`).join(' ')}`);
  html.push('<br>');
  const fields = ['Open','High','Low','Close','QVol (USDT)'];
  for (let f=0; f<fields.length; f++) {
    html.push(`<span style="color:#0f0">${fields[f]}:</span>`);
    chart1.data.datasets.forEach((ds, idx) => {
      const coin = ds.label.split('/')[0];
      const data = chart2.data.datasets[idx].data[i];
      let val;
      if (f<4) val = fmtVal(fetchCache[coin][i][f+1]);
      else val = fmtVal(data, true);
      html.push(` <span style="color:${ds.borderColor}">${val}</span>`);
    });
    html.push('<br>');
  }
  hoverBox.innerHTML = html.join('');
  hoverBox.style.left = evt.chart.canvas.offsetLeft + evt.x + 20 + 'px';
  hoverBox.style.top = evt.chart.canvas.offsetTop + evt.y - 20 + 'px';
  hoverBox.style.display = 'block';
}

let fetchCache = {};

async function preload() {
  const coins = ['BTC','RAY','ACA'];
  for (let c of coins) {
    const data = await fetchKline(c);
    fetchCache[c] = data.map(d => [d.time,d.open,d.high,d.low,d.close,d.qVol]);
  }
}
preload();

document.getElementById('updateBtn').onclick = updateChart;
document.getElementById('addBtn').onclick = addCoin;
document.getElementById('smoothBtn').onclick = () => {
  smoothMode = !smoothMode;
  chart1.data.datasets.forEach(ds => { ds.tension = smoothMode ? 0.4 : 0; ds.pointRadius = smoothMode ? 0 : 3; });
  chart1.update();
  hoverBox.style.display = smoothMode ? 'none' : 'block';
};
</script>

</body>
</html>
